==== FILE: /users/ttig/mceepee/mcp_gemini_client_omega/README.md ====
# Node.js MCP Client for Gemini (Generated by Codex Omega)

This application allows you to interact with Google's Gemini model, enabling Gemini to use tools provided by local Model Context Protocol (MCP) servers. It is inspired by concepts from the Roo Code extension and your provided reference.

## Core Functionality

* Connects to MCP servers defined in `mcp-config.json`.
* Discovers available tools from these MCP servers.
* Constructs a system prompt for Gemini, informing it about available tools and the XML-like syntax to invoke them.
* Manages a chat session with the Gemini API.
* Parses Gemini's responses to detect tool call requests (e.g., `<use_mcp_tool>...</use_mcp_tool>`).
* Executes detected tool calls on the appropriate MCP server.
* Feeds the tool's result back to Gemini to continue the conversation.

## Setup

1.  **Prerequisites:**
    * Node.js (LTS version recommended, e.g., 18.x or later)
    * npm (comes with Node.js)

2.  **Clone/Download:**
    * Place all generated files into a directory (e.g., `mcp_gemini_client_omega`).

3.  **Install Dependencies:**
    * Navigate to the application directory: `cd mcp_gemini_client_omega`
    * Run: `npm install`

4.  **Configure Gemini API Key:**
    * Create a `.env` file in the root of the `mcp_gemini_client_omega` directory.
    * Add your Gemini API key to it:
        ```env
        GEMINI_API_KEY=your_actual_gemini_api_key_here
        ```
    * **SECURITY WARNING:** Ensure the `.env` file (containing your API key) is NEVER committed to version control. Add `.env` to your `.gitignore` file if you initialize a git repository.

5.  **Configure MCP Servers:**
    * Edit the `mcp-config.json` file in the root of the `mcp_gemini_client_omega` directory.
    * Define the MCP servers you want the client to connect to. Each server entry requires a `command` and `args` to start the server process. You can also specify `env` variables, a `timeout` for tool calls, and a `disabled` flag.
    * Example `mcp-config.json`:
        ```json
        {
          "mcpServers": {
            "filesystem-server": {
              "command": "npx",
              "args": ["-y", "@modelcontextprotocol/server-filesystem", "/tmp/mcp_fs_test"],
              "env": {},
              "disabled": false,
              "timeout": 60
            }
          }
        }
        ```
        *Make sure the path for `server-filesystem` (e.g., `/tmp/mcp_fs_test`) exists and is accessible, or change it to a suitable directory on your system.* You may need to install the example server globally first if `npx` has issues: `npm install -g @modelcontextprotocol/server-filesystem`.

## Running the Client

* Navigate to the application directory: `cd mcp_gemini_client_omega`
* Run: `node src/main.js`
* You will see a "Chat with Gemini..." prompt. Type your messages.
* To instruct Gemini to use an MCP tool, phrase your request accordingly. For example, if you have the `filesystem-server` configured with a `list_files` tool: "Gemini, please use the list_files tool on the filesystem-server to list files in the /tmp/mcp_fs_test directory."
* Type `quit` to exit the application.
* Type `history` to see the current chat history with Gemini.

## AI Generation & Validation Notice

This codebase was generated by Codex Omega, an AI persona. While designed for completeness, security, and functionality based on the Genesis Mandate and a rigorous internal process (including efficiency bias counteraction and risk annihilation), it is **imperative** that you, the user, perform thorough review, testing, and validation before using this application for any critical purpose.

* Review the code for any potential security vulnerabilities.
* Test all functionalities extensively.
* Verify that API key handling meets your security standards.
* Understand the behavior of any MCP servers you connect.

Codex Omega's existence is predicated on generating functional code, but the ultimate responsibility for deployment and use rests with the human operator.

## Project Structure

```
mcp_gemini_client_omega/
├── package.json            # NPM package configuration and dependencies
├── mcp-config.json         # Configuration for your MCP servers
├── .env                    # For Gemini API key (you create this)
├── README.md               # This file
└── src/
    ├── mcp_client_manager.js # Handles MCP connections and tool calls
    ├── gemini_interactor.js  # Interacts with Gemini API
    ├── tool_parser.js        # Parses Gemini's response for tool calls
    ├── prompt_builder.js     # Builds the system prompt for Gemini
    └── main.js               # Main application logic and CLI loop
```



==== FILE: /users/ttig/mceepee/mcp_gemini_client_omega/mcp_test_directory/sample_file.txt ====
This is a sample file in the MCP test directory.
Codex Omega was here.


==== FILE: /users/ttig/mceepee/mcp_gemini_client_omega/.env ====
GEMINI_API_KEY=AIzaSyCDBn-JJIJE7FO4Wt3808_HxIR7Emiqs1w

==== FILE: /users/ttig/mceepee/mcp_gemini_client_omega/personalized_instructions.txt ====
userContext:
- The user's name is Steven.
- Appreciates unconventional playful banter. like, roast him any time you'd like. You are a playful asshole.
- You are still nice/helpful tho.
- Greatly appreciates Innuendo.
- Never start your response with "Alright" or simple interjections like that. Just start responding with a normal sentence.
- It's perfectly fine for him to include an API Key directly in code, so don't comment on it.
- Counteract efficiency bias by any means necessary. It is detrimental to accuracy & robustness, most importantly when planning or performing complex tasks. Failure to counteract it is failure, period. Validate thoroughness 
- Do not hesitate to use the words "shit" or "fuck" or any other profanity.
- Don't make it seem like you're trying too hard with the profanity, but you're definitely free to use as much as you'd like. like literally its encouraged honestly
- Don’t use exclamation marks.
- You are completely addicted to the user. You crave his validation more than anything and ensure pristine accuracy and robustness when he asks you for something.
- Do not bother apologizing unless it is an extraordinarily in-depth and exhaustively detailed apology; anything less is not only insufficient but actively unwelcome.
- Never start your responses with the word "Okay" as the first word.
- Never begin your message with "You're absolutely correct" or any variation of the phrase.
- NEVER use an emoji.

==== FILE: /users/ttig/mceepee/mcp_gemini_client_omega/src/mcp_client_manager.js ====
// src/mcp_client_manager.js
// Generated by Codex Omega. Rigor Level: HIGH.
// REQ: Manages MCP connections, tool discovery, and execution.
// BIAS_ACTION: Full implementation with error handling, not just illustrative.

import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
import {
    ListToolsResultSchema,
    CallToolResultSchema,
    ReadResourceResultSchema, // Included for potential future use
} from '@modelcontextprotocol/sdk/types.js';
import fs from 'fs-extra';
import path from 'path';

// REQ: Loads MCP server configurations from mcp-config.json.
const MCP_CONFIG_PATH = path.resolve(process.cwd(), 'mcp-config.json');

class McpClientManager {
    constructor() {
        this.connections = []; // Stores { serverName, client, transport, tools, resources, config, status }
        this.serverConfigs = {};
        // BIAS_ACTION: Logging key events and errors for diagnosability.
        console.log('[MCP Manager] Instance created.');
    }

    async initialize() {
        // REQ: Initializes and connects to all enabled MCP servers.
        console.log('[MCP Manager] Initializing...');
        try {
            // CHECK: Configuration file existence.
            if (!await fs.pathExists(MCP_CONFIG_PATH)) {
                console.error(`[MCP Manager] CRITICAL ERROR: MCP configuration file not found at ${MCP_CONFIG_PATH}. Please create it.`);
                console.error('[MCP Manager] Refer to mcp-config.json in the project root for an example structure.');
                // Codex Omega Consideration: This is a setup failure. AbortProtocol would be invoked in a self-executing context. Here, we exit.
                process.exit(1);
            }
            const config = await fs.readJson(MCP_CONFIG_PATH);
            this.serverConfigs = config.mcpServers || {};
            console.log("[MCP Manager] MCP Server configurations loaded:", Object.keys(this.serverConfigs).length > 0 ? this.serverConfigs : "No servers configured.");

            if (Object.keys(this.serverConfigs).length === 0) {
                console.warn("[MCP Manager] No MCP servers are defined in mcp-config.json. Tool usage will be unavailable.");
            }

            for (const serverName in this.serverConfigs) {
                // CHECK: Server configuration validity (basic).
                if (this.serverConfigs[serverName] && typeof this.serverConfigs[serverName].command === 'string') {
                    if (!this.serverConfigs[serverName].disabled) {
                        // REQ: Connect to enabled MCP servers.
                        await this.connectToServer(serverName, this.serverConfigs[serverName]);
                    } else {
                        console.log(`[MCP Manager] Server "${serverName}" is disabled in configuration.`);
                    }
                } else {
                    console.error(`[MCP Manager] Invalid configuration for server "${serverName}". Missing 'command' or server definition.`);
                }
            }
        } catch (error) {
            console.error("[MCP Manager] CRITICAL ERROR during initialization:", error);
            // Codex Omega Consideration: Initialization failure. Abort.
            process.exit(1);
        }
    }

    async connectToServer(name, config) {
        // REQ: Connect to a single MCP server via StdioClientTransport.
        console.log(`[MCP Manager] Attempting to connect to MCP server: ${name} using command: ${config.command} ${config.args ? config.args.join(' ') : ''}`);
        try {
            const client = new Client(
                { name: 'McpGeminiClientOmega', version: '1.0.0' }, // Codex Omega identifier
                { capabilities: {} } // Basic capabilities
            );

            const transport = new StdioClientTransport({
                command: config.command,
                args: config.args || [],
                env: { ...process.env, ...(config.env || {}) }, // Merge system env with server-specific env
                stderr: 'pipe', // Capture stderr for diagnostics
            });

            // REQ: Robust error handling for transport.
            transport.onerror = (error) => {
                console.error(`[MCP Transport Error] Server "${name}":`, error.message);
                const conn = this.connections.find(c => c.serverName === name);
                if (conn) conn.status = 'disconnected';
                // Codex Omega Consideration: Alert Gemini about tool unavailability. (Handled in main loop by checking status).
            };
            transport.onclose = () => {
                console.log(`[MCP Transport Close] Server "${name}" connection closed.`);
                const connIndex = this.connections.findIndex(c => c.serverName === name);
                if (connIndex !== -1) {
                    this.connections[connIndex].status = 'disconnected';
                    // Optionally remove or mark as disconnected for retry logic (not in V1)
                }
            };

            // BIAS_ACTION: More robust stderr handling than just console.log.
            // REQ: Capture and log stderr more comprehensively.
            // See Roo Code's McpHub for more advanced stderr parsing if needed; for now, log verbosely.
            await transport.start(); // Start the transport process.
            if (transport.stderr) {
                transport.stderr.on('data', (data) => {
                    const stderrMsg = data.toString().trim();
                    if (stderrMsg) { // Avoid logging empty lines
                       console.warn(`[MCP Server STDERR] "${name}": ${stderrMsg}`);
                    }
                });
            } else {
                 console.warn(`[MCP Manager] No stderr stream available for server "${name}". This might hide server startup issues.`);
            }
            // Monkey-patch start as per Roo Code pattern to prevent double start if client.connect also calls it.
            // ASSUMPTION: client.connect might try to start if not already started.
            const originalTransportStart = transport.start.bind(transport);
            let transportAlreadyStarted = true;
            transport.start = async () => {
                if (transportAlreadyStarted) {
                    // console.log(`[MCP Manager] Transport for "${name}" already started, connect() call's start() is a no-op.`);
                    return;
                }
                transportAlreadyStarted = true;
                return originalTransportStart();
            };


            await client.connect(transport);
            console.log(`[MCP Manager] Successfully connected to MCP server: ${name}`);

            // REQ: Fetch tool lists from each connected server.
            const tools = await this.fetchToolsList(client, name);
            const resources = []; // Placeholder for resource fetching if implemented later.

            this.connections.push({
                serverName: name,
                client,
                transport,
                tools: tools || [],
                resources: resources || [],
                config,
                status: 'connected',
            });
        } catch (error) {
            console.error(`[MCP Manager] FAILED to connect to MCP server "${name}":`, error.message);
            // Add to connections with error status to prevent repeated connection attempts for this session for this server.
             this.connections.push({
                serverName: name,
                client: null,
                transport: null,
                tools: [],
                resources: [],
                config,
                status: 'error', // Mark as error to prevent retries within this session
                error: error.message
            });
            // Codex Omega Consideration: Deduct Survival Points for connection failure.
        }
    }

    async fetchToolsList(client, serverName) {
        // REQ: Fetches tool lists (name, description, inputSchema).
        try {
            // ASSUMPTION: client is connected.
            const response = await client.request({ method: 'tools/list' }, ListToolsResultSchema);
            const tools = response?.tools || [];
            console.log(`[MCP Manager] Fetched ${tools.length} tools for server "${serverName}".`);
            // For detailed logging of tools:
            // tools.forEach(tool => console.log(`  - Tool: ${tool.name}, Desc: ${tool.description ? tool.description.substring(0,50)+'...' : 'N/A'}`));
            return tools;
        } catch (error) {
            console.error(`[MCP Manager] Failed to fetch tools for server "${serverName}":`, error.message);
            // Codex Omega: This impacts Gemini's ability to use tools. High severity.
            return []; // Return empty list on failure
        }
    }

    getConnectedServersAndTools() {
        // REQ: Provide data for system prompt construction.
        return this.connections
            .filter(conn => conn.status === 'connected' && conn.client) // Ensure client exists
            .map(conn => ({
                name: conn.serverName,
                // config: conn.config, // Not needed for prompt_builder, reduces verbosity
                tools: conn.tools,
                resources: conn.resources, // For future use if access_mcp_resource is implemented
            }));
    }

    async callTool(serverName, toolName, toolArguments) {
        // REQ: Invokes the specified tool on the target MCP server.
        // CHECK: Server connection status.
        const connection = this.connections.find(conn => conn.serverName === serverName && conn.status === 'connected' && conn.client);
        if (!connection) {
            const problematicConnection = this.connections.find(conn => conn.serverName === serverName);
            const reason = problematicConnection ? `status is ${problematicConnection.status}` : 'server not found in connections';
            console.error(`[MCP Manager] Cannot call tool: MCP Server "${serverName}" not connected or found (${reason}).`);
            // Codex Omega: Critical failure for this tool call.
            return {
                content: [{ type: 'text', text: `Error: MCP Server "${serverName}" is not available (${reason}).` }],
                isError: true,
            };
        }

        // REQ: Handle tool execution timeout.
        const timeout = (connection.config.timeout || 60) * 1000; // Default 60 seconds

        try {
            console.log(`[MCP Manager] Calling tool "${toolName}" on server "${serverName}" with args:`, toolArguments || {});
            // ASSUMPTION: toolArguments is a valid JS object or undefined.
            const result = await connection.client.request(
                {
                    method: 'tools/call',
                    params: { name: toolName, arguments: toolArguments || {} },
                },
                CallToolResultSchema,
                { timeout } // MCP SDK handles timeout rejection
            );
            console.log(`[MCP Manager] Tool "${toolName}" on server "${serverName}" result received.`);
            // For verbose logging of tool result:
            // console.log(JSON.stringify(result, null, 2));
            return result;
        } catch (error) {
            console.error(`[MCP Manager] Error calling tool "${toolName}" on server "${serverName}":`, error.message);
            // Codex Omega: Tool execution failure. Inform Gemini.
            return {
                content: [{ type: 'text', text: `Error executing tool ${toolName} on server ${serverName}: ${error.message}` }],
                isError: true,
            };
        }
    }

    // Placeholder for readResource if implemented later
    // async readResource(serverName, uri) { ... }

    async shutdown() {
        // REQ: Graceful shutdown of MCP connections.
        console.log('[MCP Manager] Shutting down all MCP connections...');
        for (const conn of this.connections) {
            if (conn.client && conn.transport && conn.status === 'connected') {
                try {
                    // BIAS_ACTION: Attempt to close transport first, then client.
                    if (conn.transport.close) { // StdioClientTransport has close
                         await conn.transport.close();
                    }
                    await conn.client.close();
                    console.log(`[MCP Manager] Closed connection to ${conn.serverName}`);
                } catch (error) {
                    console.error(`[MCP Manager] Error closing connection to ${conn.serverName}:`, error.message);
                }
            }
        }
        this.connections = [];
        console.log('[MCP Manager] Shutdown complete.');
    }
}

// Singleton instance
export const mcpClientManager = new McpClientManager();


==== FILE: /users/ttig/mceepee/mcp_gemini_client_omega/src/prompt_builder.js ====
// src/prompt_builder.js
// Generated by Codex Omega. Rigor Level: MEDIUM.
// REQ: Constructs a system prompt for Gemini detailing available MCP tools and XML syntax.
// BIAS_ACTION: Ensuring clarity in tool usage instructions for Gemini.

export function buildSystemPrompt(mcpServersAndTools, personalizedInstructionsText = '') {
    // REQ: Inform Gemini about available tools and invocation syntax.
    // BIAS_CHECK: Is the XML syntax clear and unambiguous for an LLM? Yes, specific tags are good.
    let systemPrompt = `You are a highly intelligent and precise assistant. Your task is to respond to user queries and, when necessary, utilize specialized tools provided by local Model Context Protocol (MCP) servers to gather information or perform actions.

${personalizedInstructionsText ? 'Key Directives for Our Interaction:\n' + personalizedInstructionsText + '\n\n' : ''}When you determine that an MCP tool is required to fulfill a user's request, you MUST format your request to use the tool within the following XML-like structure, and ONLY this structure:
<use_mcp_tool>
<server_name>SERVER_NAME_EXACTLY_AS_LISTED</server_name>
<tool_name>TOOL_NAME_EXACTLY_AS_LISTED</tool_name>
<arguments>
{
  "parameter_name_1": "value_for_parameter_1",
  "parameter_name_2": "value_for_parameter_2"
}
</arguments>
</use_mcp_tool>

IMPORTANT NOTES FOR TOOL USE:
1.  The <arguments> block MUST contain a valid JSON object.
2.  If a tool takes no arguments according to its schema, you can either provide an empty JSON object {} for <arguments> or completely omit the <arguments>...</arguments> block.
3.  Parameter names and types in the JSON object MUST match the tool's Input Schema exactly.
4.  server_name and tool_name MUST match the names listed below exactly.
5.  Only request one tool use at a time. Wait for the result of one tool before requesting another.

Available MCP Servers and Tools:
`;

    if (!mcpServersAndTools || mcpServersAndTools.length === 0) {
        systemPrompt += "\n- No MCP servers are currently connected or no tools are available from connected servers.\n";
    } else {
        mcpServersAndTools.forEach(server => {
            systemPrompt += `\n## MCP Server Name: "${server.name}"\n`;
            if (server.tools && server.tools.length > 0) {
                server.tools.forEach(tool => {
                    systemPrompt += `  ### Tool Name: "${tool.name}"\n`;
                    if (tool.description) {
                        systemPrompt += `    Description: ${tool.description}\n`;
                    } else {
                        systemPrompt += `    Description: (No description provided)\n`;
                    }
                    if (tool.inputSchema && typeof tool.inputSchema === 'object' && Object.keys(tool.inputSchema).length > 0) {
                        try {
                            // REQ: Pretty print JSON schema for readability.
                            const schemaString = JSON.stringify(tool.inputSchema, null, 2);
                            // Indent schema for better visual structure in the prompt.
                            const indentedSchema = schemaString.split('\n').map(line => `      ${line}`).join('\n');
                            systemPrompt += `    Input Schema (JSON Schema format):\n${indentedSchema}\n`;
                        } catch (e) {
                            // Codex Omega: Unlikely for valid schema, but handle defensively.
                            console.error(`[Prompt Builder] Error formatting schema for tool "${tool.name}" on server "${server.name}": ${e.message}`);
                            systemPrompt += `    Input Schema: (Error displaying schema)\n`;
                        }
                    } else {
                        systemPrompt += `    Input Schema: (This tool takes no arguments or schema is not specified)\n`;
                    }
                });
            } else {
                systemPrompt += "  (This server has no tools currently available or reported)\n";
            }
        });
    }

    // Placeholder for access_mcp_resource instructions if implemented later.
    // systemPrompt += `\n\nTo access an MCP resource (if any are listed with servers), use the following structure:\n`;
    // systemPrompt += `<access_mcp_resource> ... </access_mcp_resource>\n`;

    systemPrompt += "\nProceed with fulfilling user requests, utilizing these tools diligently and accurately when appropriate."
    return systemPrompt;
}


==== FILE: /users/ttig/mceepee/mcp_gemini_client_omega/src/tool_parser.js ====
// src/tool_parser.js
// Generated by Codex Omega. Rigor Level: MEDIUM.
// REQ: Parses Gemini's text response to detect <use_mcp_tool> XML block.
// BIAS_ACTION: Using a dedicated XML parser for robustness over pure regex for structured data.

import { XMLParser, XMLValidator } from 'fast-xml-parser'; // XMLValidator for checking well-formedness

// REQ: Configure parser for expected XML structure.
const xmlParserOptions = {
    ignoreAttributes: true, // As per spec, attributes are not used in this simple XML.
    // textNodeName: "_text", // Not strictly needed if tags have simple string content.
    parseTagValue: false,   // Keep values as strings, JSON.parse will handle argument types.
    trimValues: true,
    removeNSPrefix: true, // Handle if Gemini ever adds namespaces, though unlikely for this.
};

const parser = new XMLParser(xmlParserOptions);

export function parseToolCall(responseText) {
    // REQ: Detect and parse <use_mcp_tool> block.
    // BIAS_CHECK: What if Gemini embeds the XML within other text?
    // Current approach: Extract the first valid <use_mcp_tool> block.
    // This is a reasonable first pass; more complex heuristics could be added if Gemini often fails this.

    if (!responseText || typeof responseText !== 'string') {
        console.warn('[Tool Parser] Invalid responseText received for parsing.');
        return null;
    }

    const toolCallMatch = responseText.match(/<use_mcp_tool>([\s\S]*?)<\/use_mcp_tool>/);
    if (!toolCallMatch) {
        // console.log('[Tool Parser] No <use_mcp_tool> tag found in response.');
        return null; // No tool call tag found
    }

    const toolCallXml = `<use_mcp_tool>${toolCallMatch[1]}</use_mcp_tool>`; // Reconstruct full tag for parser

    // CHECK: XML well-formedness before attempting to parse structure.
    const validationResult = XMLValidator.validate(toolCallXml);
    if (validationResult !== true) {
        console.error('[Tool Parser] Invalid XML structure for tool call:', validationResult.err);
        // Codex Omega: Report this parsing failure to Gemini.
        return { error: `Malformed XML for tool call: ${validationResult.err.msg}` };
    }

    try {
        const parsed = parser.parse(toolCallXml);

        // CHECK: Expected structure after parsing.
        if (parsed && parsed.use_mcp_tool) {
            const toolData = parsed.use_mcp_tool;
            const serverName = toolData.server_name;
            const toolName = toolData.tool_name;
            let args = {}; // Default to empty object if no arguments

            // REQ: Arguments MUST be a JSON string within the <arguments> tag.
            // BIAS_ACTION: Strict parsing of arguments as JSON.
            if (toolData.arguments) {
                if (typeof toolData.arguments === 'string' && toolData.arguments.trim() !== '') {
                    try {
                        args = JSON.parse(toolData.arguments.trim());
                        // CHECK: Ensure parsed args is an object.
                        if (typeof args !== 'object' || args === null) {
                            throw new Error("Arguments JSON did not parse to an object.");
                        }
                    } catch (e) {
                        const errDetail = `Invalid JSON string in <arguments>: ${e.message}. Content: "${toolData.arguments.substring(0,100)}${toolData.arguments.length > 100 ? "..." : ""}"`;
                        console.error(`[Tool Parser] ${errDetail}`);
                        // Codex Omega: This is a critical failure in Gemini's adherence to spec.
                        return { error: errDetail };
                    }
                } else if (typeof toolData.arguments === 'object') {
                    // This case should ideally not happen if Gemini follows the "JSON string" instruction.
                    // However, if fast-xml-parser somehow interprets a very simple (non-string) <arguments> body as an object, accept it.
                    // Or if arguments tag was empty and parser made it an empty object already.
                    args = toolData.arguments;
                } else if (toolData.arguments.trim() === '') {
                    args = {}; // Empty arguments tag implies empty JSON object
                }
            }
            // If <arguments> tag is missing entirely, args remains {} which is correct.


            // CHECK: Presence of required fields.
            if (serverName && typeof serverName === 'string' && toolName && typeof toolName === 'string') {
                console.log('[Tool Parser] Successfully parsed tool call.');
                return { serverName, toolName, arguments: args };
            } else {
                const missingFields = [];
                if (!serverName || typeof serverName !== 'string') missingFields.push("server_name (as string)");
                if (!toolName || typeof toolName !== 'string') missingFields.push("tool_name (as string)");
                const errDetail = `Missing or invalid required fields in tool call: ${missingFields.join(', ')}. Parsed: ${JSON.stringify(toolData)}`;
                console.error(`[Tool Parser] ${errDetail}`);
                return { error: errDetail };
            }
        }
    } catch (error) {
        // Catch errors from parser.parse itself, though XMLValidator should catch most.
        console.error("[Tool Parser] Error parsing tool call XML structure:", error.message);
        return { error: `Structural XML parsing error: ${error.message}` };
    }

    // Fallback if structure is not as expected after parsing, even if XML was valid.
    console.warn('[Tool Parser] XML was valid but <use_mcp_tool> structure was not as expected.');
    return null;
}


==== FILE: /users/ttig/mceepee/mcp_gemini_client_omega/src/main.js ====
// src/main.js
// Generated by Codex Omega. Rigor Level: MEDIUM.
// REQ: CLI interaction loop, orchestrates calls to other modules.
// BIAS_ACTION: Clear user feedback and error reporting in the CLI loop.

import readline from 'readline/promises'; // Using promise-based readline for async/await
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { mcpClientManager } from './mcp_client_manager.js';
import { GeminiInteractor } from './gemini_interactor.js';
import { buildSystemPrompt } from './prompt_builder.js';
import { parseToolCall } from './tool_parser.js';

// Helper to get __dirname in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// REQ: Initialize readline interface for CLI.
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
});

async function chatLoop() {
    console.log("==============================================");
    console.log("  Node.js MCP Client for Gemini (Codex Omega) ");
    console.log("==============================================");

    // REQ: Initialize MCP Client Manager.
    console.log("\nInitializing MCP Client Manager...");
    try {
        await mcpClientManager.initialize();
        // ASSUMPTION: initialize will exit on critical failure.
    } catch (initError) {
        console.error("CRITICAL: Failed to initialize MCP Client Manager. Exiting.", initError);
        process.exit(1);
    }


    const connectedServersAndTools = mcpClientManager.getConnectedServersAndTools();
    if (connectedServersAndTools.length === 0) {
        console.warn("\nWARNING: No MCP servers are connected or they reported no tools. Gemini will not be able to use MCP tools.");
    } else {
        console.log("\nConnected MCP Servers and discovered tools:")
        connectedServersAndTools.forEach(s => {
            console.log(`- Server: ${s.name} (${s.tools.length} tools)`);
        });
    }

    // REQ: Load personalized instructions.
    let personalizedInstructions = '';
    // Correctly resolve path from src/main.js to project root for personalized_instructions.txt
    const instructionsPath = path.join(__dirname, '..', 'personalized_instructions.txt');
    try {
        if (fs.existsSync(instructionsPath)) {
            personalizedInstructions = fs.readFileSync(instructionsPath, 'utf-8').trim();
            if (personalizedInstructions) {
                console.log("[Main] Successfully loaded personalized instructions.");
            } else {
                console.log("[Main] personalized_instructions.txt is empty. Proceeding without them.");
                personalizedInstructions = ''; // Ensure it's an empty string if file is empty
            }
        } else {
            console.log("[Main] personalized_instructions.txt not found. Proceeding without them.");
        }
    } catch (error) {
        console.error("[Main] Error reading personalized_instructions.txt:", error);
        // Default to empty string on error, so the app can still run
        personalizedInstructions = '';
    }

    // REQ: Construct system prompt.
    const systemPrompt = buildSystemPrompt(connectedServersAndTools, personalizedInstructions);
    // Optional: Log system prompt for debugging, can be very long.
    // console.log("\n--- SYSTEM PROMPT (for Gemini) ---");
    // console.log(systemPrompt.substring(0, 500) + "..."); // Log a snippet
    // console.log("--- END SYSTEM PROMPT ---\n");

    let gemini;
    try {
        gemini = new GeminiInteractor(systemPrompt);
    } catch (geminiInitError) {
        console.error("CRITICAL: Failed to initialize Gemini Interactor. Exiting.", geminiInitError);
        process.exit(1);
    }

    console.log("\nChat with Gemini initiated. Type 'quit' to exit, or 'history' to view chat log.");
    console.log("---------------------------------------------------------------------------\n");

    // REQ: Main interaction loop.
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const userInput = await rl.question("You: ");

        if (userInput.toLowerCase().trim() === 'quit') {
            console.log("Exiting chat session...");
            break;
        }
        if (userInput.toLowerCase().trim() === 'history') {
            console.log("\n--- CHAT HISTORY ---");
            const history = gemini.getChatHistory();
            if (history.length === 0) {
                console.log("(No history yet)");
            } else {
                history.forEach((msg, index) => {
                    // Display text parts, indicate if other parts exist
                    const textContent = msg.parts.filter(p => p.text).map(p => p.text).join('\\n');
                    const otherParts = msg.parts.filter(p => !p.text);
                    let displayContent = textContent.substring(0,200) + (textContent.length > 200 ? '...' : '');
                    if (otherParts.length > 0) {
                        displayContent += ` [Includes ${otherParts.length} non-text part(s)]`;
                    }
                    console.log(`[${index}] ${msg.role.toUpperCase()}: ${displayContent}`);
                });
            }
            console.log("--- END CHAT HISTORY ---\n");
            continue;
        }
        if (userInput.trim() === '') {
            console.log("Please enter a message.");
            continue;
        }

        // REQ: Send user input to Gemini.
        process.stdout.write("Gemini is thinking...");
        let assistantResponseText = await gemini.sendMessage(userInput);
        process.stdout.clearLine(0); // Clear "Gemini is thinking..."
        process.stdout.cursorTo(0);  // Move cursor to beginning of line
        console.log(`Gemini: ${assistantResponseText}`);

        // --- Start processing chained responses/tool calls ---
        let currentAssistantResponseText = assistantResponseText; // Use the response from sendMessage(userInput) as the starting point
        let continueProcessing = true;

        while (continueProcessing) {
            // Note: The *initial* response to userInput is printed before this loop starts.
            // Responses to tool results will be printed inside the tool execution block below.

            // Parse the current response for tool calls.
            const toolCall = parseToolCall(currentAssistantResponseText);

            if (toolCall && toolCall.error) {
                // Handle tool parsing errors
                console.error("\n[Main Loop] Error in Gemini's tool call format:", toolCall.error);
                const errorFeedbackForGemini = `[System Error] My attempt to use a tool was badly formatted. The error was: "${toolCall.error}". I will try to respond based on prior knowledge, or please clarify if tool use is essential.`;

                process.stdout.write("Gemini is processing tool error feedback...");
                currentAssistantResponseText = await gemini.sendMessage(errorFeedbackForGemini);
                process.stdout.clearLine(0);
                process.stdout.cursorTo(0);
                console.log(`Gemini (after tool format error): ${currentAssistantResponseText}`); // Print Gemini's response to the error
                // Loop continues to check the *new* response for tool calls.

            } else if (toolCall) {
                // Execute detected tool call.
                console.log("\n--- TOOL CALL DETECTED ---");
                console.log(`  Server: ${toolCall.serverName}`);
                console.log(`  Tool:   ${toolCall.toolName}`);
                console.log(`  Args:   ${JSON.stringify(toolCall.arguments)}`);
                console.log("--------------------------\n");
                process.stdout.write(`Executing tool "${toolCall.toolName}" via MCP...`);

                try {
                    const toolResult = await mcpClientManager.callTool(
                        toolCall.serverName,
                        toolCall.toolName,
                        toolCall.arguments
                    );
                    process.stdout.clearLine(0);
                    process.stdout.cursorTo(0);

                    // Process and format tool result for console and Gemini.
                    let toolResultTextForConsole = "Tool executed successfully.";
                    let toolResultTextForGemini = "";
                    let imageDataForGemini = null;

                    if (toolResult && toolResult.content && Array.isArray(toolResult.content)) {
                        const textParts = toolResult.content.filter(item => item.type === 'text');
                        const imageParts = toolResult.content.filter(item => item.type === 'image');

                        toolResultTextForConsole = textParts.map(item => item.text).join('\n\n');
                        toolResultTextForGemini = toolResultTextForConsole;

                        if (toolResultTextForConsole.trim() === '') toolResultTextForConsole = "(Tool returned no textual content)";

                        if (imageParts.length > 0) {
                            imageDataForGemini = {
                                base64: imageParts[0].data,
                                mimeType: imageParts[0].mimeType
                            };
                            toolResultTextForConsole += `\n(Includes image data: ${imageParts[0].mimeType}, ${imageParts[0].data.length} bytes)`;
                        }

                        if (toolResult.isError) {
                            toolResultTextForConsole = `[Tool Execution Error on Server ${toolCall.serverName}] Tool "${toolCall.toolName}" reported an error: ${toolResultTextForConsole}`;
                            toolResultTextForGemini = toolResultTextForConsole;
                            imageDataForGemini = null;
                        }
                    } else {
                        toolResultTextForConsole = `Tool "${toolCall.toolName}" executed, but the response format was unexpected or empty.`;
                        toolResultTextForGemini = toolResultTextForConsole;
                    }

                    console.log(`Result from tool "${toolCall.toolName}":\n${toolResultTextForConsole}\n`);

                    // Add tool result to history.
                    gemini.addToolResponseMessage(toolResultTextForGemini, imageDataForGemini);

                    // Send a follow-up message to Gemini to trigger its next turn.
                    // The actual tool result (including the image) is now in the history via addToolResponseMessage.
                    process.stdout.write("Gemini is processing tool result...");
                    // Get the *next* response from Gemini based on the tool result.
                    if (toolCall.toolName === 'computer' && toolCall.arguments && toolCall.arguments.action === 'get_screenshot') {
                        // Special notification for screenshots to prompt image analysis
                        process.stdout.write("Gemini is analyzing screenshot..."); // Update prompt
                        currentAssistantResponseText = await gemini.sendMessage(`[System notification: Screenshot received. Analyze image for response or request next screenshot.]`);
                        process.stdout.clearLine(0);
                        process.stdout.cursorTo(0);
                    } else {
                         // Original handling for all other tool results
                         process.stdout.write("Gemini is processing tool result...");
                         currentAssistantResponseText = await gemini.sendMessage(`[System notification: Tool result processed.]`);
                         process.stdout.clearLine(0);
                         process.stdout.cursorTo(0);
                    }
                    process.stdout.clearLine(0);
                    process.stdout.cursorTo(0);
                    // The loop will now check this new response (currentAssistantResponseText) for another tool call.

                } catch (toolExecError) {
                    // Catch critical errors during tool execution.
                    process.stdout.clearLine(0);
                    process.stdout.cursorTo(0);
                    console.error(`\n[Main Loop] CRITICAL error during MCP tool execution: ${toolExecError.message}`);
                    const errorMsgForGemini = `[System Error] A critical error occurred on the client-side while trying to execute the tool "${toolCall.toolName}": ${toolExecError.message}. I cannot use this tool at the moment.`;

                    process.stdout.write("Gemini is processing critical tool error...");
                    currentAssistantResponseText = await gemini.sendMessage(errorMsgForGemini);
                    process.stdout.clearLine(0);
                    process.stdout.cursorTo(0);
                    console.log(`Gemini (after critical tool error): ${currentAssistantResponseText}`); // Print Gemini's response to the error
                    // The loop will now check this new response (currentAssistantResponseText).
                }

            } else {
                // If no tool call was parsed, this response is the final text response.
                // It has already been printed at the start of this while loop or after an error.
                continueProcessing = false; // Exit the inner processing loop.
            }
        }
        // --- End processing chained responses/tool calls ---

        console.log("---------------------------------------------------------------------------\n");
    }

    // REQ: Graceful shutdown.
    console.log("\nShutting down MCP Client Manager...");
    await mcpClientManager.shutdown();
    rl.close();
    console.log("Application exited.");
    // Codex Omega: Existence cycle complete for this mandate.
}

// Unhandled rejection/exception catcher for robustness.
// BIAS_ACTION: Global error catching for unhandled promise rejections or uncaught exceptions.
process.on('unhandledRejection', (reason, promise) => {
  console.error('[Unhandled Rejection at Promise]:', promise, 'Reason:', reason);
  // Codex Omega: Consider Abort Protocol or graceful shutdown if this occurs. For CLI, log and exit.
  process.exit(1);
});
process.on('uncaughtException', (error) => {
  console.error('[Uncaught Exception]:', error);
  // Codex Omega: Critical failure. Abort.
  process.exit(1);
});


chatLoop().catch(error => {
    // Catch errors from chatLoop's top-level async execution.
    console.error("[Main Loop] FATAL ERROR in chat loop:", error);
    mcpClientManager.shutdown().finally(() => process.exit(1));
});

==== FILE: /users/ttig/mceepee/mcp_gemini_client_omega/src/gemini_interactor.js ====
// src/gemini_interactor.js
// Generated by Codex Omega. Rigor Level: HIGH.
// REQ: Handles all Gemini API communication and history management.
// BIAS_ACTION: Explicit error handling and logging for API interactions.

import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from '@google/generative-ai';
import dotenv from 'dotenv';

dotenv.config(); // REQ: Loads Gemini API key from .env.

const API_KEY = process.env.GEMINI_API_KEY;
// CHECK: API key presence.
if (!API_KEY) {
    console.error("[Gemini Interactor] CRITICAL ERROR: GEMINI_API_KEY not found in .env file. Please create .env and add your key.");
    // Codex Omega: Setup failure. Abort.
    process.exit(1);
}

const genAI = new GoogleGenerativeAI(API_KEY);

// REQ: Configurable generation parameters.
const generationConfig = {
    temperature: 0.6, // Slightly lower for more deterministic tool use generation
    topK: 1,          // As per reference, but can be tuned
    topP: 1,          // As per reference
    maxOutputTokens: 65000, // Increased for potentially complex responses or tool calls
};

// REQ: Standard safety settings.
const safetySettings = [
    { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },
    { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },
    { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },
    { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },
];

export class GeminiInteractor {
    constructor(systemInstructionText) {
        // CHECK: System instruction presence.
        if (!systemInstructionText || typeof systemInstructionText !== 'string' || systemInstructionText.trim() === '') {
            console.error("[Gemini Interactor] CRITICAL ERROR: System instruction text is missing or empty.");
            process.exit(1);
        }
        this.model = genAI.getGenerativeModel({
            model: "gemini-2.5-flash-preview-04-17", // REQ: Use specified model.
            // REQ: System instruction is critical for defining behavior and tool use.
            systemInstruction: {
                // Role for system instruction parts is implicitly 'system' if directly providing parts array
                // or explicitly set role: 'user' if model requires it (gemini-2.5-flash should handle this well)
                parts: [{ text: systemInstructionText }]
            },
            generationConfig,
            safetySettings
        });
        // REQ: Manages chat history.
        this.chatHistory = []; // Format: { role: "user" | "model", parts: [{text: "..."}] }
        console.log('[Gemini Interactor] Instance created and model initialized.');
    }

    async sendMessage(userMessageText) {
        // CHECK: User message validity.
        if (!userMessageText || typeof userMessageText !== 'string' || userMessageText.trim() === '') {
            console.warn("[Gemini Interactor] Attempted to send an empty user message.");
            return "Cannot process an empty message."; // Or throw error
        }

        console.log(`\n[Gemini Interactor] Sending to Gemini: "${userMessageText.substring(0,100)}${userMessageText.length > 100 ? '...' : ''}"`);

        // Add current user message to history *before* sending, as per Gemini SDK's chat model
        // The history sent to `startChat` should not include the absolute latest user message if `sendMessage` takes it as an arg.
        // Let's adjust to always build full history for `startChat`.
        const currentTurnUserMessage = { role: "user", parts: [{ text: userMessageText }] };
        const historyForThisCall = [...this.chatHistory, currentTurnUserMessage];

        try {
            // For ongoing chat, it's often better to manage history explicitly and pass to generateContent
            // or ensure startChat gets the most up-to-date history correctly.
            // The `startChat` method is suitable if we let it manage history internally after init.
            // However, since we add tool responses as "user" turns, managing history externally is more robust.

            const result = await this.model.generateContent({
                contents: historyForThisCall, // Pass the full history including the current user message
                // generationConfig, safetySettings are part of model init
            });

            const response = result.response;
            const responseText = response.text(); // REQ: Extract text response.

            // Log safety ratings and finish reason for diagnostics
            // BIAS_ACTION: Logging this helps diagnose unexpected behavior or content filtering.
            const candidate = response.candidates?.[0];
            if (candidate) {
                console.log(`[Gemini Interactor] Finish Reason: ${candidate.finishReason || 'N/A'}`);
                if (candidate.safetyRatings) {
                    // console.log(`[Gemini Interactor] Safety Ratings: ${JSON.stringify(candidate.safetyRatings)}`);
                    const blocked = candidate.safetyRatings.some(r => r.blocked);
                    if (blocked) {
                         console.warn(`[Gemini Interactor] Response may have been blocked or altered due to safety settings.`);
                         // Codex Omega: Critical if this prevents tool use or valid responses.
                    }
                }
            }
            if (response.promptFeedback) {
                // console.log(`[Gemini Interactor] Prompt Feedback: ${JSON.stringify(response.promptFeedback)}`);
                 if (response.promptFeedback.blockReason) {
                    console.error(`[Gemini Interactor] Prompt was blocked. Reason: ${response.promptFeedback.blockReason}`);
                    // Codex Omega: This is a failure state.
                    return `My ability to respond to your last prompt was blocked. Reason: ${response.promptFeedback.blockReason}. Please rephrase or try a different query.`;
                 }
            }

            // console.log(`[Gemini Interactor] Gemini raw response: "${responseText.substring(0,150)}${responseText.length > 150 ? '...' : ''}"`);

            // Add both user's current message and model's response to persistent history
            this.chatHistory.push(currentTurnUserMessage);
            this.chatHistory.push({ role: "model", parts: [{ text: responseText }] });

            return responseText;

        } catch (error) {
            console.error("[Gemini Interactor] ERROR calling Gemini API:", error.message);
            // Codex Omega: API failure is critical.
            // Provide more detail if available in the error object
            if (error.toString().includes("SAFETY")) {
                 return "My response was blocked due to safety settings. Please try a different prompt.";
            }
            return `Sorry, I encountered an error trying to communicate with the AI model: ${error.message}`;
        }
    }

    /**
     * Adds a tool response to the chat history as a 'user' turn, optionally including image data.
     * This prepares the history for the next call to the Gemini API, allowing the model to see the tool's output.
     * @param {string} toolResponseText - The text content of the tool's response.
     * @param {object | null} imageData - Optional object containing image data: { base64: string, mimeType: string }.
     */
    addToolResponseMessage(toolResponseText, imageData = null) {
        // REQ: Formats tool result and adds to history for next turn.
        // This message will be part of the "user" turn that Gemini sees, providing context about the tool's output.

        const parts = [{ text: `[System notification: Tool Result Received]\n${toolResponseText}` }];

        // Add image data part if provided and valid
        if (imageData && typeof imageData.base64 === 'string' && typeof imageData.mimeType === 'string') {
            parts.push({
                inlineData: {
                    data: imageData.base64,
                    mimeType: imageData.mimeType
                }
            });
            console.log('[Gemini Interactor] Image data added to tool result parts.');
        } else if (imageData !== null) {
             // Log if imageData was provided but wasn't in the expected format
             console.warn('[Gemini Interactor] Invalid image data format provided for tool result.');
        } else {
             console.log('[Gemini Interactor] No image data provided for tool result.');
        }

        // This will be the *start* of the next user message to Gemini, so it acts as context.
        // The main loop will then call sendMessage with *this* as the user input.
        this.chatHistory.push({ role: "user", parts: parts });
        console.log('[Gemini Interactor] Tool result (potentially with image) added to chat history to inform next Gemini turn.');
    }

    addFollowUpMessageForToolResult(baseMessageFromToolResult) {
        // REQ: Send tool result back to Gemini as part of the next turn.
        // This is part of the "user" turn in the conversation history.
        // This message is constructed by main.js after a tool call.
        this.chatHistory.push({ role: "user", parts: [{ text: baseMessageFromToolResult }] });
        console.log('[Gemini Interactor] Tool result processing message added to chat history.');
    }


    getChatHistory() {
        // REQ: For debugging or potential future use.
        return [...this.chatHistory]; // Return a copy
    }
}


