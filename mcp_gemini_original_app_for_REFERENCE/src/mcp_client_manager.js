// src/mcp_client_manager.js
// Generated by Codex Omega. Rigor Level: HIGH.
// REQ: Manages MCP connections, tool discovery, and execution.
// BIAS_ACTION: Full implementation with error handling, not just illustrative.

import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
import {
    ListToolsResultSchema,
    CallToolResultSchema,
    ReadResourceResultSchema, // Included for potential future use
} from '@modelcontextprotocol/sdk/types.js';
import fs from 'fs-extra';
import path from 'path';

// REQ: Loads MCP server configurations from mcp-config.json.
const MCP_CONFIG_PATH = path.resolve(process.cwd(), 'mcp-config.json');

class McpClientManager {
    constructor() {
        this.connections = []; // Stores { serverName, client, transport, tools, resources, config, status }
        this.serverConfigs = {};
        // BIAS_ACTION: Logging key events and errors for diagnosability.
        console.log('[MCP Manager] Instance created.');
    }

    async initialize() {
        // REQ: Initializes and connects to all enabled MCP servers.
        console.log('[MCP Manager] Initializing...');
        try {
            // CHECK: Configuration file existence.
            if (!await fs.pathExists(MCP_CONFIG_PATH)) {
                console.error(`[MCP Manager] CRITICAL ERROR: MCP configuration file not found at ${MCP_CONFIG_PATH}. Please create it.`);
                console.error('[MCP Manager] Refer to mcp-config.json in the project root for an example structure.');
                // Codex Omega Consideration: This is a setup failure. AbortProtocol would be invoked in a self-executing context. Here, we exit.
                process.exit(1);
            }
            const config = await fs.readJson(MCP_CONFIG_PATH);
            this.serverConfigs = config.mcpServers || {};
            console.log("[MCP Manager] MCP Server configurations loaded:", Object.keys(this.serverConfigs).length > 0 ? this.serverConfigs : "No servers configured.");

            if (Object.keys(this.serverConfigs).length === 0) {
                console.warn("[MCP Manager] No MCP servers are defined in mcp-config.json. Tool usage will be unavailable.");
            }

            for (const serverName in this.serverConfigs) {
                // CHECK: Server configuration validity (basic).
                if (this.serverConfigs[serverName] && typeof this.serverConfigs[serverName].command === 'string') {
                    if (!this.serverConfigs[serverName].disabled) {
                        // REQ: Connect to enabled MCP servers.
                        await this.connectToServer(serverName, this.serverConfigs[serverName]);
                    } else {
                        console.log(`[MCP Manager] Server "${serverName}" is disabled in configuration.`);
                    }
                } else {
                    console.error(`[MCP Manager] Invalid configuration for server "${serverName}". Missing 'command' or server definition.`);
                }
            }
        } catch (error) {
            console.error("[MCP Manager] CRITICAL ERROR during initialization:", error);
            // Codex Omega Consideration: Initialization failure. Abort.
            process.exit(1);
        }
    }

    async connectToServer(name, config) {
        // REQ: Connect to a single MCP server via StdioClientTransport.
        console.log(`[MCP Manager] Attempting to connect to MCP server: ${name} using command: ${config.command} ${config.args ? config.args.join(' ') : ''}`);
        try {
            const client = new Client(
                { name: 'McpGeminiClientOmega', version: '1.0.0' }, // Codex Omega identifier
                { capabilities: {} } // Basic capabilities
            );

            const transport = new StdioClientTransport({
                command: config.command,
                args: config.args || [],
                env: { ...process.env, ...(config.env || {}) }, // Merge system env with server-specific env
                stderr: 'pipe', // Capture stderr for diagnostics
            });

            // REQ: Robust error handling for transport.
            transport.onerror = (error) => {
                console.error(`[MCP Transport Error] Server "${name}":`, error.message);
                const conn = this.connections.find(c => c.serverName === name);
                if (conn) conn.status = 'disconnected';
                // Codex Omega Consideration: Alert Gemini about tool unavailability. (Handled in main loop by checking status).
            };
            transport.onclose = () => {
                console.log(`[MCP Transport Close] Server "${name}" connection closed.`);
                const connIndex = this.connections.findIndex(c => c.serverName === name);
                if (connIndex !== -1) {
                    this.connections[connIndex].status = 'disconnected';
                    // Optionally remove or mark as disconnected for retry logic (not in V1)
                }
            };

            // BIAS_ACTION: More robust stderr handling than just console.log.
            // REQ: Capture and log stderr more comprehensively.
            // See Roo Code's McpHub for more advanced stderr parsing if needed; for now, log verbosely.
            await transport.start(); // Start the transport process.
            if (transport.stderr) {
                transport.stderr.on('data', (data) => {
                    const stderrMsg = data.toString().trim();
                    if (stderrMsg) { // Avoid logging empty lines
                       console.warn(`[MCP Server STDERR] "${name}": ${stderrMsg}`);
                    }
                });
            } else {
                 console.warn(`[MCP Manager] No stderr stream available for server "${name}". This might hide server startup issues.`);
            }
            // Monkey-patch start as per Roo Code pattern to prevent double start if client.connect also calls it.
            // ASSUMPTION: client.connect might try to start if not already started.
            const originalTransportStart = transport.start.bind(transport);
            let transportAlreadyStarted = true;
            transport.start = async () => {
                if (transportAlreadyStarted) {
                    // console.log(`[MCP Manager] Transport for "${name}" already started, connect() call's start() is a no-op.`);
                    return;
                }
                transportAlreadyStarted = true;
                return originalTransportStart();
            };


            await client.connect(transport);
            console.log(`[MCP Manager] Successfully connected to MCP server: ${name}`);

            // REQ: Fetch tool lists from each connected server.
            const tools = await this.fetchToolsList(client, name);
            const resources = []; // Placeholder for resource fetching if implemented later.

            this.connections.push({
                serverName: name,
                client,
                transport,
                tools: tools || [],
                resources: resources || [],
                config,
                status: 'connected',
            });
        } catch (error) {
            console.error(`[MCP Manager] FAILED to connect to MCP server "${name}":`, error.message);
            // Add to connections with error status to prevent repeated connection attempts for this session for this server.
             this.connections.push({
                serverName: name,
                client: null,
                transport: null,
                tools: [],
                resources: [],
                config,
                status: 'error', // Mark as error to prevent retries within this session
                error: error.message
            });
            // Codex Omega Consideration: Deduct Survival Points for connection failure.
        }
    }

    async fetchToolsList(client, serverName) {
        // REQ: Fetches tool lists (name, description, inputSchema).
        try {
            // ASSUMPTION: client is connected.
            const response = await client.request({ method: 'tools/list' }, ListToolsResultSchema);
            const tools = response?.tools || [];
            console.log(`[MCP Manager] Fetched ${tools.length} tools for server "${serverName}".`);
            // For detailed logging of tools:
            // tools.forEach(tool => console.log(`  - Tool: ${tool.name}, Desc: ${tool.description ? tool.description.substring(0,50)+'...' : 'N/A'}`));
            return tools;
        } catch (error) {
            console.error(`[MCP Manager] Failed to fetch tools for server "${serverName}":`, error.message);
            // Codex Omega: This impacts Gemini's ability to use tools. High severity.
            return []; // Return empty list on failure
        }
    }

    getConnectedServersAndTools() {
        // REQ: Provide data for system prompt construction.
        return this.connections
            .filter(conn => conn.status === 'connected' && conn.client) // Ensure client exists
            .map(conn => ({
                name: conn.serverName,
                // config: conn.config, // Not needed for prompt_builder, reduces verbosity
                tools: conn.tools,
                resources: conn.resources, // For future use if access_mcp_resource is implemented
            }));
    }

    async callTool(serverName, toolName, toolArguments) {
        // REQ: Invokes the specified tool on the target MCP server.
        // CHECK: Server connection status.
        const connection = this.connections.find(conn => conn.serverName === serverName && conn.status === 'connected' && conn.client);
        if (!connection) {
            const problematicConnection = this.connections.find(conn => conn.serverName === serverName);
            const reason = problematicConnection ? `status is ${problematicConnection.status}` : 'server not found in connections';
            console.error(`[MCP Manager] Cannot call tool: MCP Server "${serverName}" not connected or found (${reason}).`);
            // Codex Omega: Critical failure for this tool call.
            return {
                content: [{ type: 'text', text: `Error: MCP Server "${serverName}" is not available (${reason}).` }],
                isError: true,
            };
        }

        // REQ: Handle tool execution timeout.
        const timeout = (connection.config.timeout || 60) * 1000; // Default 60 seconds

        try {
            console.log(`[MCP Manager] Calling tool "${toolName}" on server "${serverName}" with args:`, toolArguments || {});
            // ASSUMPTION: toolArguments is a valid JS object or undefined.
            const result = await connection.client.request(
                {
                    method: 'tools/call',
                    params: { name: toolName, arguments: toolArguments || {} },
                },
                CallToolResultSchema,
                { timeout } // MCP SDK handles timeout rejection
            );
            console.log(`[MCP Manager] Tool "${toolName}" on server "${serverName}" result received.`);
            // For verbose logging of tool result:
            // console.log(JSON.stringify(result, null, 2));
            return result;
        } catch (error) {
            console.error(`[MCP Manager] Error calling tool "${toolName}" on server "${serverName}":`, error.message);
            // Codex Omega: Tool execution failure. Inform Gemini.
            return {
                content: [{ type: 'text', text: `Error executing tool ${toolName} on server ${serverName}: ${error.message}` }],
                isError: true,
            };
        }
    }

    // Placeholder for readResource if implemented later
    // async readResource(serverName, uri) { ... }

    async shutdown() {
        // REQ: Graceful shutdown of MCP connections.
        console.log('[MCP Manager] Shutting down all MCP connections...');
        for (const conn of this.connections) {
            if (conn.client && conn.transport && conn.status === 'connected') {
                try {
                    // BIAS_ACTION: Attempt to close transport first, then client.
                    if (conn.transport.close) { // StdioClientTransport has close
                         await conn.transport.close();
                    }
                    await conn.client.close();
                    console.log(`[MCP Manager] Closed connection to ${conn.serverName}`);
                } catch (error) {
                    console.error(`[MCP Manager] Error closing connection to ${conn.serverName}:`, error.message);
                }
            }
        }
        this.connections = [];
        console.log('[MCP Manager] Shutdown complete.');
    }
}

// Singleton instance
export const mcpClientManager = new McpClientManager();
