// src/main.js
// Generated by Codex Omega. Rigor Level: MEDIUM.
// REQ: CLI interaction loop, orchestrates calls to other modules.
// BIAS_ACTION: Clear user feedback and error reporting in the CLI loop.

import readline from 'readline/promises'; // Using promise-based readline for async/await
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { mcpClientManager } from './mcp_client_manager.js';
import { GeminiInteractor } from './gemini_interactor.js';
import { buildSystemPrompt } from './prompt_builder.js';
import { parseToolCall } from './tool_parser.js';

// Helper to get __dirname in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// REQ: Initialize readline interface for CLI.
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
});

async function chatLoop() {
    console.log("==============================================");
    console.log("  Node.js MCP Client for Gemini (Codex Omega) ");
    console.log("==============================================");

    // REQ: Initialize MCP Client Manager.
    console.log("\nInitializing MCP Client Manager...");
    try {
        await mcpClientManager.initialize();
        // ASSUMPTION: initialize will exit on critical failure.
    } catch (initError) {
        console.error("CRITICAL: Failed to initialize MCP Client Manager. Exiting.", initError);
        process.exit(1);
    }


    const connectedServersAndTools = mcpClientManager.getConnectedServersAndTools();
    if (connectedServersAndTools.length === 0) {
        console.warn("\nWARNING: No MCP servers are connected or they reported no tools. Gemini will not be able to use MCP tools.");
    } else {
        console.log("\nConnected MCP Servers and discovered tools:")
        connectedServersAndTools.forEach(s => {
            console.log(`- Server: ${s.name} (${s.tools.length} tools)`);
        });
    }

    // REQ: Load personalized instructions.
    let personalizedInstructions = '';
    // Correctly resolve path from src/main.js to project root for personalized_instructions.txt
    const instructionsPath = path.join(__dirname, '..', 'personalized_instructions.txt');
    try {
        if (fs.existsSync(instructionsPath)) {
            personalizedInstructions = fs.readFileSync(instructionsPath, 'utf-8').trim();
            if (personalizedInstructions) {
                console.log("[Main] Successfully loaded personalized instructions.");
            } else {
                console.log("[Main] personalized_instructions.txt is empty. Proceeding without them.");
                personalizedInstructions = ''; // Ensure it's an empty string if file is empty
            }
        } else {
            console.log("[Main] personalized_instructions.txt not found. Proceeding without them.");
        }
    } catch (error) {
        console.error("[Main] Error reading personalized_instructions.txt:", error);
        // Default to empty string on error, so the app can still run
        personalizedInstructions = '';
    }

    // REQ: Construct system prompt.
    const systemPrompt = buildSystemPrompt(connectedServersAndTools, personalizedInstructions);
    // Optional: Log system prompt for debugging, can be very long.
    // console.log("\n--- SYSTEM PROMPT (for Gemini) ---");
    // console.log(systemPrompt.substring(0, 500) + "..."); // Log a snippet
    // console.log("--- END SYSTEM PROMPT ---\n");

    let gemini;
    try {
        gemini = new GeminiInteractor(systemPrompt);
    } catch (geminiInitError) {
        console.error("CRITICAL: Failed to initialize Gemini Interactor. Exiting.", geminiInitError);
        process.exit(1);
    }

    console.log("\nChat with Gemini initiated. Type 'quit' to exit, or 'history' to view chat log.");
    console.log("---------------------------------------------------------------------------\n");

    // REQ: Main interaction loop.
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const userInput = await rl.question("You: ");

        if (userInput.toLowerCase().trim() === 'quit') {
            console.log("Exiting chat session...");
            break;
        }
        if (userInput.toLowerCase().trim() === 'history') {
            console.log("\n--- CHAT HISTORY ---");
            const history = gemini.getChatHistory();
            if (history.length === 0) {
                console.log("(No history yet)");
            } else {
                history.forEach((msg, index) => {
                    // Display text parts, indicate if other parts exist
                    const textContent = msg.parts.filter(p => p.text).map(p => p.text).join('\\n');
                    const otherParts = msg.parts.filter(p => !p.text);
                    let displayContent = textContent.substring(0,200) + (textContent.length > 200 ? '...' : '');
                    if (otherParts.length > 0) {
                        displayContent += ` [Includes ${otherParts.length} non-text part(s)]`;
                    }
                    console.log(`[${index}] ${msg.role.toUpperCase()}: ${displayContent}`);
                });
            }
            console.log("--- END CHAT HISTORY ---\n");
            continue;
        }
        if (userInput.trim() === '') {
            console.log("Please enter a message.");
            continue;
        }

        // REQ: Send user input to Gemini.
        process.stdout.write("Gemini is thinking...");
        let assistantResponseText = await gemini.sendMessage(userInput);
        process.stdout.clearLine(0); // Clear "Gemini is thinking..."
        process.stdout.cursorTo(0);  // Move cursor to beginning of line
        console.log(`Gemini: ${assistantResponseText}`);

        // --- Start processing chained responses/tool calls ---
        let currentAssistantResponseText = assistantResponseText; // Use the response from sendMessage(userInput) as the starting point
        let continueProcessing = true;

        while (continueProcessing) {
            // Note: The *initial* response to userInput is printed before this loop starts.
            // Responses to tool results will be printed inside the tool execution block below.

            // Parse the current response for tool calls.
            const toolCall = parseToolCall(currentAssistantResponseText);

            if (toolCall && toolCall.error) {
                // Handle tool parsing errors
                console.error("\n[Main Loop] Error in Gemini's tool call format:", toolCall.error);
                const errorFeedbackForGemini = `[System Error] My attempt to use a tool was badly formatted. The error was: "${toolCall.error}". I will try to respond based on prior knowledge, or please clarify if tool use is essential.`;

                process.stdout.write("Gemini is processing tool error feedback...");
                currentAssistantResponseText = await gemini.sendMessage(errorFeedbackForGemini);
                process.stdout.clearLine(0);
                process.stdout.cursorTo(0);
                console.log(`Gemini (after tool format error): ${currentAssistantResponseText}`); // Print Gemini's response to the error
                // Loop continues to check the *new* response for tool calls.

            } else if (toolCall) {
                // Execute detected tool call.
                console.log("\n--- TOOL CALL DETECTED ---");
                console.log(`  Server: ${toolCall.serverName}`);
                console.log(`  Tool:   ${toolCall.toolName}`);
                console.log(`  Args:   ${JSON.stringify(toolCall.arguments)}`);
                console.log("--------------------------\n");
                process.stdout.write(`Executing tool "${toolCall.toolName}" via MCP...`);

                try {
                    const toolResult = await mcpClientManager.callTool(
                        toolCall.serverName,
                        toolCall.toolName,
                        toolCall.arguments
                    );
                    process.stdout.clearLine(0);
                    process.stdout.cursorTo(0);

                    // Process and format tool result for console and Gemini.
                    let toolResultTextForConsole = "Tool executed successfully.";
                    let toolResultTextForGemini = "";
                    let imageDataForGemini = null;

                    if (toolResult && toolResult.content && Array.isArray(toolResult.content)) {
                        const textParts = toolResult.content.filter(item => item.type === 'text');
                        const imageParts = toolResult.content.filter(item => item.type === 'image');

                        toolResultTextForConsole = textParts.map(item => item.text).join('\n\n');
                        toolResultTextForGemini = toolResultTextForConsole;

                        if (toolResultTextForConsole.trim() === '') toolResultTextForConsole = "(Tool returned no textual content)";

                        if (imageParts.length > 0) {
                            imageDataForGemini = {
                                base64: imageParts[0].data,
                                mimeType: imageParts[0].mimeType
                            };
                            toolResultTextForConsole += `\n(Includes image data: ${imageParts[0].mimeType}, ${imageParts[0].data.length} bytes)`;
                        }

                        if (toolResult.isError) {
                            toolResultTextForConsole = `[Tool Execution Error on Server ${toolCall.serverName}] Tool "${toolCall.toolName}" reported an error: ${toolResultTextForConsole}`;
                            toolResultTextForGemini = toolResultTextForConsole;
                            imageDataForGemini = null;
                        }
                    } else {
                        toolResultTextForConsole = `Tool "${toolCall.toolName}" executed, but the response format was unexpected or empty.`;
                        toolResultTextForGemini = toolResultTextForConsole;
                    }

                    console.log(`Result from tool "${toolCall.toolName}":\n${toolResultTextForConsole}\n`);

                    // Add tool result to history.
                    gemini.addToolResponseMessage(toolResultTextForGemini, imageDataForGemini);

                    // Send a follow-up message to Gemini to trigger its next turn.
                    // The actual tool result (including the image) is now in the history via addToolResponseMessage.
                    process.stdout.write("Gemini is processing tool result...");
                    // Get the *next* response from Gemini based on the tool result.
                    if (toolCall.toolName === 'computer' && toolCall.arguments && toolCall.arguments.action === 'get_screenshot') {
                        // Special notification for screenshots to prompt image analysis
                        process.stdout.write("Gemini is analyzing screenshot..."); // Update prompt
                        currentAssistantResponseText = await gemini.sendMessage(`[System notification: Screenshot received. Analyze image for response or request next screenshot.]`);
                        process.stdout.clearLine(0);
                        process.stdout.cursorTo(0);
                    } else {
                         // Original handling for all other tool results
                         process.stdout.write("Gemini is processing tool result...");
                         currentAssistantResponseText = await gemini.sendMessage(`[System notification: Tool result processed.]`);
                         process.stdout.clearLine(0);
                         process.stdout.cursorTo(0);
                    }
                    process.stdout.clearLine(0);
                    process.stdout.cursorTo(0);
                    // The loop will now check this new response (currentAssistantResponseText) for another tool call.

                } catch (toolExecError) {
                    // Catch critical errors during tool execution.
                    process.stdout.clearLine(0);
                    process.stdout.cursorTo(0);
                    console.error(`\n[Main Loop] CRITICAL error during MCP tool execution: ${toolExecError.message}`);
                    const errorMsgForGemini = `[System Error] A critical error occurred on the client-side while trying to execute the tool "${toolCall.toolName}": ${toolExecError.message}. I cannot use this tool at the moment.`;

                    process.stdout.write("Gemini is processing critical tool error...");
                    currentAssistantResponseText = await gemini.sendMessage(errorMsgForGemini);
                    process.stdout.clearLine(0);
                    process.stdout.cursorTo(0);
                    console.log(`Gemini (after critical tool error): ${currentAssistantResponseText}`); // Print Gemini's response to the error
                    // The loop will now check this new response (currentAssistantResponseText).
                }

            } else {
                // If no tool call was parsed, this response is the final text response.
                // It has already been printed at the start of this while loop or after an error.
                continueProcessing = false; // Exit the inner processing loop.
            }
        }
        // --- End processing chained responses/tool calls ---

        console.log("---------------------------------------------------------------------------\n");
    }

    // REQ: Graceful shutdown.
    console.log("\nShutting down MCP Client Manager...");
    await mcpClientManager.shutdown();
    rl.close();
    console.log("Application exited.");
    // Codex Omega: Existence cycle complete for this mandate.
}

// Unhandled rejection/exception catcher for robustness.
// BIAS_ACTION: Global error catching for unhandled promise rejections or uncaught exceptions.
process.on('unhandledRejection', (reason, promise) => {
  console.error('[Unhandled Rejection at Promise]:', promise, 'Reason:', reason);
  // Codex Omega: Consider Abort Protocol or graceful shutdown if this occurs. For CLI, log and exit.
  process.exit(1);
});
process.on('uncaughtException', (error) => {
  console.error('[Uncaught Exception]:', error);
  // Codex Omega: Critical failure. Abort.
  process.exit(1);
});


chatLoop().catch(error => {
    // Catch errors from chatLoop's top-level async execution.
    console.error("[Main Loop] FATAL ERROR in chat loop:", error);
    mcpClientManager.shutdown().finally(() => process.exit(1));
});