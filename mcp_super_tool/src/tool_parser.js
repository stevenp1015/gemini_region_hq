// src/tool_parser.js
// Generated by Codex Omega. Rigor Level: MEDIUM.
// REQ: Parses Gemini's text response to detect <use_mcp_tool> XML block.
// BIAS_ACTION: Using a dedicated XML parser for robustness over pure regex for structured data.

import { XMLParser, XMLValidator } from 'fast-xml-parser'; // XMLValidator for checking well-formedness

// REQ: Configure parser for expected XML structure.
const xmlParserOptions = {
    ignoreAttributes: true, // As per spec, attributes are not used in this simple XML.
    // textNodeName: "_text", // Not strictly needed if tags have simple string content.
    parseTagValue: false,   // Keep values as strings, JSON.parse will handle argument types.
    trimValues: true,
    removeNSPrefix: true, // Handle if Gemini ever adds namespaces, though unlikely for this.
};

const parser = new XMLParser(xmlParserOptions);

export function parseToolCall(responseText) {
    // REQ: Detect and parse <use_mcp_tool> block.
    // BIAS_CHECK: What if Gemini embeds the XML within other text?
    // Current approach: Extract the first valid <use_mcp_tool> block.
    // This is a reasonable first pass; more complex heuristics could be added if Gemini often fails this.

    if (!responseText || typeof responseText !== 'string') {
        console.warn('[Tool Parser] Invalid responseText received for parsing.');
        return null;
    }

    const toolCallMatch = responseText.match(/<use_mcp_tool>([\s\S]*?)<\/use_mcp_tool>/);
    if (!toolCallMatch) {
        // console.log('[Tool Parser] No <use_mcp_tool> tag found in response.');
        return null; // No tool call tag found
    }

    const toolCallXml = `<use_mcp_tool>${toolCallMatch[1]}</use_mcp_tool>`; // Reconstruct full tag for parser

    // CHECK: XML well-formedness before attempting to parse structure.
    const validationResult = XMLValidator.validate(toolCallXml);
    if (validationResult !== true) {
        console.error('[Tool Parser] Invalid XML structure for tool call:', validationResult.err);
        // Codex Omega: Report this parsing failure to Gemini.
        return { error: `Malformed XML for tool call: ${validationResult.err.msg}` };
    }

    try {
        const parsed = parser.parse(toolCallXml);

        // CHECK: Expected structure after parsing.
        if (parsed && parsed.use_mcp_tool) {
            const toolData = parsed.use_mcp_tool;
            const serverName = toolData.server_name;
            const toolName = toolData.tool_name;
            let args = {}; // Default to empty object if no arguments

            // REQ: Arguments MUST be a JSON string within the <arguments> tag.
            // BIAS_ACTION: Strict parsing of arguments as JSON.
            if (toolData.arguments) {
                if (typeof toolData.arguments === 'string' && toolData.arguments.trim() !== '') {
                    try {
                        args = JSON.parse(toolData.arguments.trim());
                        // CHECK: Ensure parsed args is an object.
                        if (typeof args !== 'object' || args === null) {
                            throw new Error("Arguments JSON did not parse to an object.");
                        }
                    } catch (e) {
                        const errDetail = `Invalid JSON string in <arguments>: ${e.message}. Content: "${toolData.arguments.substring(0,100)}${toolData.arguments.length > 100 ? "..." : ""}"`;
                        console.error(`[Tool Parser] ${errDetail}`);
                        // Codex Omega: This is a critical failure in Gemini's adherence to spec.
                        return { error: errDetail };
                    }
                } else if (typeof toolData.arguments === 'object') {
                    // This case should ideally not happen if Gemini follows the "JSON string" instruction.
                    // However, if fast-xml-parser somehow interprets a very simple (non-string) <arguments> body as an object, accept it.
                    // Or if arguments tag was empty and parser made it an empty object already.
                    args = toolData.arguments;
                } else if (toolData.arguments.trim() === '') {
                    args = {}; // Empty arguments tag implies empty JSON object
                }
            }
            // If <arguments> tag is missing entirely, args remains {} which is correct.


            // CHECK: Presence of required fields.
            if (serverName && typeof serverName === 'string' && toolName && typeof toolName === 'string') {
                console.log('[Tool Parser] Successfully parsed tool call.');
                return { serverName, toolName, arguments: args };
            } else {
                const missingFields = [];
                if (!serverName || typeof serverName !== 'string') missingFields.push("server_name (as string)");
                if (!toolName || typeof toolName !== 'string') missingFields.push("tool_name (as string)");
                const errDetail = `Missing or invalid required fields in tool call: ${missingFields.join(', ')}. Parsed: ${JSON.stringify(toolData)}`;
                console.error(`[Tool Parser] ${errDetail}`);
                return { error: errDetail };
            }
        }
    } catch (error) {
        // Catch errors from parser.parse itself, though XMLValidator should catch most.
        console.error("[Tool Parser] Error parsing tool call XML structure:", error.message);
        return { error: `Structural XML parsing error: ${error.message}` };
    }

    // Fallback if structure is not as expected after parsing, even if XML was valid.
    console.warn('[Tool Parser] XML was valid but <use_mcp_tool> structure was not as expected.');
    return null;
}
